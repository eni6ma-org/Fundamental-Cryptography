# Cryptographic apparatus and method

### InventorMartin : E. HellmanBailey W. DiffieRalph C. MerkleCurrent 
### Assignee :  Stanford  University

## Abstract
A cryptographic system transmits a computationally secure cryptogram over an insecure communication channel without prearrangement of a cipher key. A secure cipher key is generated by the conversers from transformations of exchanged transformed signals. The conversers each possess a secret signal and exchange an initial transformation of the secret signal with the other converser. The received transformation of the other converser's secret signal is again transformed with the receiving converser's secret signal to generate a secure cipher key. The transformations use non-secret operations that are easily performed but extremely difficult to invert. It is infeasible for an eavesdropper to invert the initial transformation to obtain either conversers' secret signal, or duplicate the latter transformation to obtain the secure cipher key.

## The Claims : Algorithm & Equations  

 1. SecureKeyGenerator(firstSignal, secondSignal)
    a. Input1 <- firstSignal
    b. Input2 <- secondSignal
    c. Output1 = Transform(Input1)  # Transformation is infeasible to invert
       - Equation: $Y_i = a^{X_i} \mod q$
    d. Output2 = Transform(Input2 with Input1)  # Represents a secure key
       - Equation: $K = (Y_j)^{X_i} \mod q = a^{X_i X_j} \mod q$

 2. SecureCommunication(transmitter, receiver)
    a. firstSignal <- GenerateSignal(transmitter)
    b. secondSignal <- GenerateSignal(receiver)
    c. transformedFirstSignal = Transform(firstSignal)
       - Equation: $Y_i = a^{X_i} \mod q$
    d. transformedSecondSignal = Transform(secondSignal)
       - Equation: $Y_j = a^{X_j} \mod q$
    e. Transmit(transformedFirstSignal, receiver)
    f. Transmit(transformedSecondSignal, transmitter)
    g. thirdSignal = Transform(transformedSecondSignal with firstSignal)
       - Equation: $K = (Y_j)^{X_i} \mod q$
    h. fourthSignal = Transform(transformedFirstSignal with secondSignal)
       - Equation: $K = (Y_i)^{X_j} \mod q$
    i. Encipher and transmit message with secureKey
    j. Decipher received message with secureKey

 3. Authentication(transmitter, receiver)
    - If receiver generates fourthSignal, identity authenticated
      - Equation: $K = (Y_j)^{X_i} \mod q$

 4. GenerateSecureKey(transmitter, receiver)
    a. Same as steps in 2.a to 2.h
    b. Secure key generation without direct cipher key exchange

 5. SecureCipherKeyApparatus(firstSignal, secondSignal)
    - Combines functionalities of SecureKeyGenerator and GenerateSecureKey
    - Uses transformations that are infeasible to invert for key generation

 6. SecureCipherKeyMethod(firstSignal, secondSignal)
    - Detailed steps for generating a secure cipher key using transformations that are infeasible to invert
    - Equation for transforming firstSignal: $Y_i = a^{X_i} \mod q$
    - Equation for generating secure cipher key: $K = (Y_j)^{X_i} \mod q$

 7. SecureCipherKeyApparatusVariation(firstSignal, secondSignal)
    - Variation of SecureCipherKeyApparatus for generating a secure cipher key with additional transformations

 8. AdvancedSecureCipherKeyGenerator(firstSignal, secondSignal)
    - An advanced apparatus for generating a secure cipher key
    - Equations for generating third and fourth signals:
      - Third signal: $Y_i = a^{X_i} \mod q$
      - Fourth signal: $K_{ij} = Y_j^{X_i} \mod q$
    - Equations for generating second and sixth signals:
      - Second signal: $Y_j = a^{X_j} \mod q$
      - Sixth signal: $K_{ij} = Y_i^{X_j} \mod q$




## Diffie-Hellman Key Exchange Algorithm  

1. **Transformation and Exchange Process:**
    - Each participant (converser) begins with a secret signal.
    - They transform their secret signal using public parameters and exchange the transformed signal with the other participant.
    - The transformation involves raising a base number to the power of their secret signal, modulo a large prime number.
    - The received transformed signal from the other participant is then re-transformed with the participant's own secret signal to generate a secure cipher key.

2. **Equations Involved:**
    - **Initial Transformation:** $Y_i = a^{X_i} \mod q$
      - Where $Y_i$ is the transformed signal, $a$ is the base number, $X_i$ is the secret signal, and $q$ is the large prime number.
    - **Secure Cipher Key Generation:** $K = (Y_j)^{X_i} \mod q = a^{X_i X_j} \mod q$
      - $K$ is the secure cipher key generated by both participants using the other's transformed signal $Y_j$ and their own secret signal $X_i$.

3. **Implementation Details:**
    - The transformation functions use non-secret operations that are easy to perform but difficult to invert, making it infeasible for an eavesdropper to obtain the secret signals or the secure cipher key.
    - The secure key generation method described allows communication over an insecure channel without prior exchange of a cipher key, enhancing security and privacy.


Initial Signal Transformation:
- For Converser $i$: $γ_i = α^{ξ_i} \mod ϑ$
  
Secure Cipher Key Generation:
For Converser 1:
$κ = γ_2^{ξ_1} \mod ϑ$
For Converser 2:
$κ = γ_1^{ξ_2} \mod ϑ$


Symbol Key:
- $α$: Public base used for transformation.
- $ξ_i$: Secret signal of the $x_i$ th converser.
- $γ_i$: Transformed signal of the $x_i$ th converser.
- $ϑ$: Large prime number.
- $κ$: Secure cipher key generated.

# Pseudo code Algorithm 

Given the complexity and depth of the patent claims, a straightforward translation into pseudocode for each claim, while incorporating the associated mathematical equations, provides a comprehensive view of the cryptographic process described. The pseudocode is designed to highlight the logical flow and key operations specified in the claims, ensuring each step's intent and execution are clearly understood. 

### Pseudocode for Patent Claims

#### Claim 1: Secure Key Generator

function SecureKeyGenerator(firstSignal, secondSignal):
    // Inputs: firstSignal, secondSignal
    // Outputs: thirdSignal, fourthSignal

    thirdSignal = Transform(firstSignal)  // Transformation infeasible to invert
    fourthSignal = TransformWith(firstSignal, secondSignal)  // Represents a secure key

    return thirdSignal, fourthSignal

_Equation for Transformation:_ \(Y_i = a^{X_i} \mod q\)

#### Claim 2: Secure Communication Over Insecure Channel

function SecureCommunication(transmitterFirstSignal, receiverSecondSignal):
    // Transmitter Side
    transformedFirstSignal = Transform(transmitterFirstSignal)
    Transmit(transformedFirstSignal)

    // Receiver Side
    transformedSecondSignal = Transform(receiverSecondSignal)
    Transmit(transformedSecondSignal)

    // Generating Secure Cipher Key
    thirdSignal = TransformWith(transformedSecondSignal, transmitterFirstSignal)
    fourthSignal = TransformWith(transformedFirstSignal, receiverSecondSignal)

    // Use thirdSignal or fourthSignal as the secure cipher key for encryption/decryption

_Equations for Secure Cipher Key Generation:_ \(K = (Y_j)^{X_i} \mod q = a^{X_i X_j} \mod q\)

#### Claim 3: Authentication in Secure Communication

function AuthenticateReceiver(receiverFourthSignal):
    // If receiver can generate fourthSignal, receiver's identity is authenticated
    if Validate(receiverFourthSignal):
        return True
    else:
        return False


#### Claim 4: Secure Cipher Key Generation Method

function GenerateSecureCipherKey(firstSignal, secondSignal):
    transformedFirstSignal = Transform(firstSignal)
    Transmit(transformedFirstSignal)

    transformedSecondSignal = Transform(secondSignal)
    Transmit(transformedSecondSignal)

    thirdSignal = TransformWith(transformedSecondSignal, firstSignal)
    fourthSignal = TransformWith(transformedFirstSignal, secondSignal)

    // Both signals represent the secure cipher key
    return thirdSignal, fourthSignal


#### Claim 5: Apparatus for Generating a Secure Cipher Key

class SecureKeyGeneratorApparatus:
    def __init__(self, firstInput, secondInput):
        self.firstInput = firstInput
        self.secondInput = secondInput

    function Generate():
        thirdSignal = Transform(self.firstInput)
        fourthSignal = TransformWith(self.firstInput, self.secondInput)

        return thirdSignal, fourthSignal


#### Claim 6: Secure Cipher Key Generation with Modulo Transformation

```cpp
function GenerateSecureCipherKeyModulo(firstSignal, secondSignal, q, a):
    transformedFirstSignal = TransformModulo(firstSignal, a, q)
    transformedSecondSignal = TransformModulo(secondSignal, a, q)

    Transmit(transformedFirstSignal)
    Transmit(transformedSecondSignal)

    thirdSignal = TransformWithModulo(transformedSecondSignal, firstSignal, q)
    fourthSignal = TransformWithModulo(transformedFirstSignal, secondSignal, q)

    return thirdSignal, fourthSignal
```
Equation:_ \(K = Y_2^{X_1} \mod q = (a^{X_2})^{X_1} \mod q = a^{X_1 X_2} \mod q\)

#### Claim 7: Apparatus for Generating Secure Cipher Key with Specific Transformations

```cpp
class SecureKeyGeneratorSpecific:
    def __init__(self, firstInput, secondInput, q, a):
        self.firstInput = firstInput
        self.secondInput = secondInput
        self.q = q
        self.a = a

    function Generate():
        thirdSignal = TransformSpecific(self.firstInput, self.a, self.q)
        fourthSignal = TransformWithSpecific(self.secondInput, self.firstInput, self.a, self.q)

        return thirdSignal, fourthSignal
```

#### Claim 8: Secure Cipher Key Generation with Detailed Steps

function GenerateSecureCipherKeyDetailed(firstInput, secondInput, q, a):
    // First transformation
    $Y_i$ = TransformTo $Y_i$(a, firstInput, q)
    // Second transformation
    $K_ij$ = TransformTo $K_ij$($Y_i$, secondInput, q)

    return $K_ij$

Equation for  $Y_j = a^{X_j} \mod q$
      - Sixth signal:
 Equation for  $K_{ij} = Y_i^{X_j} \mod q$

This pseudocode reflects a high-level representation of the processes and mathematical underpinnings of the patent claims. It is intended for illustrative purposes, translating the conceptual operations into a form that can be more readily visualized and understood within the context of software development or algorithmic analysis.
