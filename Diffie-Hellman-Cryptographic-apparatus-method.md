# Cryptographic apparatus and method

### InventorMartin : E. HellmanBailey W. DiffieRalph C. MerkleCurrent 
### Assignee :  Stanford  University

## Abstract
A cryptographic system transmits a computationally secure cryptogram over an insecure communication channel without prearrangement of a cipher key. A secure cipher key is generated by the conversers from transformations of exchanged transformed signals. The conversers each possess a secret signal and exchange an initial transformation of the secret signal with the other converser. The received transformation of the other converser's secret signal is again transformed with the receiving converser's secret signal to generate a secure cipher key. The transformations use non-secret operations that are easily performed but extremely difficult to invert. It is infeasible for an eavesdropper to invert the initial transformation to obtain either conversers' secret signal, or duplicate the latter transformation to obtain the secure cipher key.

## The Claims : Algorithm & Equations  

 1. SecureKeyGenerator(firstSignal, secondSignal)
    a. Input1 <- firstSignal
    b. Input2 <- secondSignal
    c. Output1 = Transform(Input1)  # Transformation is infeasible to invert
       - Equation: $Y_i = a^{X_i} \mod q$
    d. Output2 = Transform(Input2 with Input1)  # Represents a secure key
       - Equation: $K = (Y_j)^{X_i} \mod q = a^{X_i X_j} \mod q$

 2. SecureCommunication(transmitter, receiver)
    a. firstSignal <- GenerateSignal(transmitter)
    b. secondSignal <- GenerateSignal(receiver)
    c. transformedFirstSignal = Transform(firstSignal)
       - Equation: $Y_i = a^{X_i} \mod q$
    d. transformedSecondSignal = Transform(secondSignal)
       - Equation: $Y_j = a^{X_j} \mod q$
    e. Transmit(transformedFirstSignal, receiver)
    f. Transmit(transformedSecondSignal, transmitter)
    g. thirdSignal = Transform(transformedSecondSignal with firstSignal)
       - Equation: $K = (Y_j)^{X_i} \mod q$
    h. fourthSignal = Transform(transformedFirstSignal with secondSignal)
       - Equation: $K = (Y_i)^{X_j} \mod q$
    i. Encipher and transmit message with secureKey
    j. Decipher received message with secureKey

 3. Authentication(transmitter, receiver)
    - If receiver generates fourthSignal, identity authenticated
      - Equation: $K = (Y_j)^{X_i} \mod q$

 4. GenerateSecureKey(transmitter, receiver)
    a. Same as steps in 2.a to 2.h
    b. Secure key generation without direct cipher key exchange

 5. SecureCipherKeyApparatus(firstSignal, secondSignal)
    - Combines functionalities of SecureKeyGenerator and GenerateSecureKey
    - Uses transformations that are infeasible to invert for key generation

 6. SecureCipherKeyMethod(firstSignal, secondSignal)
    - Detailed steps for generating a secure cipher key using transformations that are infeasible to invert
    - Equation for transforming firstSignal: $Y_i = a^{X_i} \mod q$
    - Equation for generating secure cipher key: $K = (Y_j)^{X_i} \mod q$

 7. SecureCipherKeyApparatusVariation(firstSignal, secondSignal)
    - Variation of SecureCipherKeyApparatus for generating a secure cipher key with additional transformations

 8. AdvancedSecureCipherKeyGenerator(firstSignal, secondSignal)
    - An advanced apparatus for generating a secure cipher key
    - Equations for generating third and fourth signals:
      - Third signal: $Y_i = a^{X_i} \mod q$
      - Fourth signal: $K_{ij} = Y_j^{X_i} \mod q$
    - Equations for generating second and sixth signals:
      - Second signal: $Y_j = a^{X_j} \mod q$
      - Sixth signal: $K_{ij} = Y_i^{X_j} \mod q$




## Diffie-Hellman Key Exchange Algorithm  

1. **Transformation and Exchange Process:**
    - Each participant (converser) begins with a secret signal.
    - They transform their secret signal using public parameters and exchange the transformed signal with the other participant.
    - The transformation involves raising a base number to the power of their secret signal, modulo a large prime number.
    - The received transformed signal from the other participant is then re-transformed with the participant's own secret signal to generate a secure cipher key.

2. **Equations Involved:**
    - **Initial Transformation:** $Y_i = a^{X_i} \mod q$
      - Where $Y_i$ is the transformed signal, $a$ is the base number, $X_i$ is the secret signal, and $q$ is the large prime number.
    - **Secure Cipher Key Generation:** $K = (Y_j)^{X_i} \mod q = a^{X_i X_j} \mod q$
      - $K$ is the secure cipher key generated by both participants using the other's transformed signal $Y_j$ and their own secret signal $X_i$.

3. **Implementation Details:**
    - The transformation functions use non-secret operations that are easy to perform but difficult to invert, making it infeasible for an eavesdropper to obtain the secret signals or the secure cipher key.
    - The secure key generation method described allows communication over an insecure channel without prior exchange of a cipher key, enhancing security and privacy.


Initial Signal Transformation:
- For Converser $i$: $γ_i = α^{ξ_i} \mod ϑ$
  
Secure Cipher Key Generation:
For Converser 1:
$κ = γ_2^{ξ_1} \mod ϑ$
For Converser 2:
$κ = γ_1^{ξ_2} \mod ϑ$


Symbol Key:
- $α$: Public base used for transformation.
- $ξ_i$: Secret signal of the $x_i$ th converser.
- $γ_i$: Transformed signal of the $x_i$ th converser.
- $ϑ$: Large prime number.
- $κ$: Secure cipher key generated.

# Pseudo code Algorithm 

Given the complexity and depth of the patent claims, a straightforward translation into pseudocode for each claim, while incorporating the associated mathematical equations, provides a comprehensive view of the cryptographic process described. The pseudocode is designed to highlight the logical flow and key operations specified in the claims, ensuring each step's intent and execution are clearly understood. 

### Pseudocode for Patent Claims

Here's how the pseudocode and corresponding equations would be formatted for GitHub Markdown, with LaTeX notation for the mathematical expressions properly escaped:

### Pseudocode and Corresponding Equations

1. **SecureKeyGenerator(firstSignal, secondSignal)**
   - `Input1 <- firstSignal`
   - `Input2 <- secondSignal`
   - `Output1 <- Transform(Input1)`
     - Equation: $Y_i = a^{X_i} \mod q$
   - `Output2 <- Transform(Input2, Input1)`
     - Equation: $K = (Y_j)^{X_i} \mod q = a^{X_i X_j} \mod q$

2. **SecureCommunication(transmitter, receiver)**
   - `firstSignal <- GenerateSignal(transmitter)`
   - `secondSignal <- GenerateSignal(receiver)`
   - `transformedFirstSignal <- Transform(firstSignal)`
     - Equation: $Y_i = a^{X_i} \mod q$
   - `transformedSecondSignal <- Transform(secondSignal)`
     - Equation: $Y_j = a^{X_j} \mod q$
   - `Transmit(transformedFirstSignal, receiver)`
   - `Transmit(transformedSecondSignal, transmitter)`
   - `thirdSignal <- Transform(transformedSecondSignal, firstSignal)`
     - Equation: $K = (Y_j)^{X_i} \mod q$
   - `fourthSignal <- Transform(transformedFirstSignal, secondSignal)`
     - Equation: $K = (Y_i)^{X_j} \mod q$
   - `Encipher and Transmit message with secureKey`
   - `Decipher received message with secureKey`

3. **Authentication(transmitter, receiver)**
   - `Verify if receiver can generate fourthSignal`
     - Equation: $K = (Y_j)^{X_i} \mod q$

4. **GenerateSecureKey(transmitter, receiver)**
   - `Repeat steps 2.a to 2.h for Secure Communication`

5. **SecureCipherKeyApparatus(firstSignal, secondSignal)**
   - `Incorporate functionalities of SecureKeyGenerator and GenerateSecureKey`
   - `Apply infeasible to invert transformations for key generation`

6. **SecureCipherKeyMethod(firstSignal, secondSignal)**
   - `Detailed method for secure cipher key generation`
     - `Transform firstSignal: $Y_i = a^{X_i} \mod q$`
     - `Generate secure cipher key: $K = (Y_j)^{X_i} \mod q$`

7. **SecureCipherKeyApparatusVariation(firstSignal, secondSignal)**
   - `Variation of SecureCipherKeyApparatus for additional transformations in key generation`

8. **AdvancedSecureCipherKeyGenerator(firstSignal, secondSignal)**
   - `Advanced apparatus for secure cipher key generation`
     - `Third signal: $Y_i = a^{X_i} \mod q$`
     - `Fourth signal: $K_{ij} = Y_j^{X_i} \mod q$`
     - `Second signal: $Y_j = a^{X_j} \mod q$`
     - `Sixth signal: $K_{ij} = Y_i^{X_j} \mod q$`
